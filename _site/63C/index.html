<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width">
    <link rel="canonical" href="/63C/">
    <link rel="shortcut icon" href="/favicon.ico">

    <!-- Google Analytics -->
    <!--<script type="text/javascript" id="_fed_an_js_tag" src="http://www.nist.gov/js/federated-analytics.all.min.js?agency=NIST&subagency=mml&pua=UA-66610693-1&yt=true&exts=ppsx,pps,f90,sch,rtf,wrl,txz,m1v,xlsm,msi,xsd,f,tif,eps,mpg,xml,pl,xlt,c"></script> -->
    <!-- DAP Analytics -->
    <script type="text/javascript" id="_fed_an_ua_tag"
            src="https://dap.digitalgov.gov/Universal-Federated-Analytics-Min.js?agency=DOC&subagency=NIST&pua=UA-66610693-1&yt=true&exts=ppsx,pps,f90,sch,rtf,wrl,txz,m1v,xlsm,msi,xsd,f,tif,eps,mpg,xml,pl,xlt,c"></script>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/RC-800-63-3/static/css/NISTStyle.css">
    <link rel="stylesheet" href="/RC-800-63-3/static/css/NISTPages.css">
    <link rel="stylesheet" href="/RC-800-63-3/static/css/graphics.css">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    
    <title>SP 800-63C</title>
    <meta property="og:title" content="SP 800-63C"/>
    

    
    <meta name="description" content="Resource Center for the NIST Special Publication 800-63 Digital Identity Guidelines">
    <meta property="og:description" content="Resource Center for the NIST Special Publication 800-63 Digital Identity Guidelines"/>
    
</head>
<body>
<header class="nist-header">
    <h1>
        <a class="nist-logo" target="_blank" href="http://www.nist.gov/" title="Go to nist.gov">National Institute of
            Standards and Technology</a>
    </h1>
    <div class="nist-links">
        <a class="nist-links-button" target="_blank" href="http://www.nist.gov">NIST Website</a>
        <a class="nist-links-button mobile-hide" target="_blank" href="http://www.nist.gov/public_affairs/nandyou.cfm">About
            NIST</a>
        <a class="nist-links-button mobile-hide" target="_blank" href="https://github.com/usnistgov">usnistgov on
            Github</a>
    </div>
</header>


<nav class="navbar navbar-default navbar-fixed-left" role="navigation">
  <ul class="nav navbar-nav">
    

    <li><a href="/RC-800-63-3/">Home</a></li>
    <li><a href="/RC-800-63-3/63-3/">SP 800-63-3</a></li>
		<ul>
			<li><a href="/RC-800-63-3/63-3/process">Process Flow</a></li>
			<li><a href="/RC-800-63-3/63-3/acceptance">Risk Accpetance</a></li>
			<li><a href="/RC-800-63-3/63-3/rmf">Risk Management</a></li>
			<li><a href="/RC-800-63-3/63-3/key_stakeholders">Key Stakeholders</a></li>
		</ul>
    <li><a href="/RC-800-63-3/63A/">SP 800-63A</a></li>
    <li><a href="/RC-800-63-3/63B/">SP 800-63B</a></li>
    <li><a href="/RC-800-63-3/63C/">SP 800-63C</a></li>
    <li>
      <a href="https://github.com/usnistgov/800-63-3/issues/" class="icon">Comment</a>
      <a href="/RC-800-63-3/comment_help.html" class="icon icon-fa">
        <i class="fa fa-question-circle" title="Get help with leaving a comment" aria-hidden="true"></i>
        <span class="sr-only">Get help with leaving a comment</span>
      </a>
    </li>
  </ul>
</nav>



<div class="container">
  <div class="row">
    <h1 id="federation-implementation-resources">Federation Implementation Resources</h1>

<h2 id="table-of-contents">Table of Contents</h2>

<h3 id="1-introduction">1. Introduction</h3>

<p>Federated identity transactions allow for a more secure and more usable internet by allowing subscribers to have a smaller number of accounts that can be used across many sites and applications, without using the same authenticator at multiple sites or applications. There are several major protocols that enable federation transactions, and a multitude of software packages and libraries that implement them. This document outlines what to look for in software that enables federation and how to apply best practices to that software to meet the requirements in SP 800-63C.</p>

<p>This document is intended to provide more direct technology discussion than SP 800-63C, which was written to be intentionally technology-agnostic. While this choice makes the SP 800-63 guidelines applicable across a wide array of technologies and circumstances, the abstract nature can make it difficult for implementers to understand what was intended by the document with regard to specific protocols or products. This guide is intended to provide more concrete information for implementors of these systems.</p>

<p>This document contains no normative requirements.</p>

<h3 id="2-choosing-security-parameters">2. Choosing Security Parameters</h3>

<p>Different federation protocols and implementations of those protocols have many options that lead to different outcomes in the security of a system. All of these options have trade-offs in terms of complexity, robustness, and other characteristics. Choosing the right set of options for a given situation helps ensure that transactions will be as secure, functional, and efficient as possible.</p>

<h3 id="21-selecting-a-federation-assurance-level-fal">2.1. Selecting a Federation Assurance Level (FAL)</h3>

<p>The Federation Assurance Level (FAL) defined in SP 800-63C [section 4] provides a set of requirements for federation transactions. These requirements are grouped into an ascending scale of three levels: FAL1, FAL2, and FAL3. Each successive level includes all the features of lower levels and adds additional requirements on top of them.</p>

<p>FAL1 provides a solid basis for federation and is appropriate for the vast majority of use cases. Most off-the-shelf products operate at FAL1 today without additional features. Most common deployments of SAML and OpenID Connect fulfill all the requirements of FAL1 today. FAL1 requires that all assertions be signed, time limited, and audience-restricted to prevent an assertion intended for one relying party to be replayed at another.</p>

<p>FAL2 provides an extra layer of security by requiring that the assertion be encrypted so that the RP is the only party that can decrypt it. This protection is required if personally identifiable information will be sent in an identity assertion, as personally identifiable information needs to be protected in transit and an assertion is sometimes borne by intermediate parties in a transaction, such as a browser. This level requires that the IdP manage an encryption key for the RP, which necessitates additional complexity for both parties. The keys could be managed with a traditional PKI infrastructure that relies on a trusted certificate authority, but with many protocols the keys can be instead registered directly between parties. The RP also needs to manage and protect its decryption keys in order to read the information in the assertion. If the client’s private decryption keys are leaked to another party, the additional protections provided by FAL2 no longer apply.</p>

<p>FAL3 is intended to be forward-looking and is not yet readily available in off-the-shelf standards and products. FAL3 provides an additional layer in the form of a cryptographic key that are presented by the subscriber in addition to the signed and encrypted assertion itself. This level requires that the IdP manage references to keys representing the subscriber at each RP in addition to managing the keys for the RPs themselves. The IdP needs to correctly associate the subscriber’s key to the correct RP in the assertion, and the RP needs to be able to process and validate the presentation of the key by the subscriber. This key could be the same key that’s presented by the subscriber at the IdP, such as an X.509 certificate, or it could be a separate key with no identity information associated with it that’s not used at the IdP, such as a FIDO token. In both cases, the assertion needs to reference the key and the RP needs to ensure the correct key is presented by the subscriber.</p>

<h3 id="22-risk-management">2.2. Risk Management</h3>

<p>Selecting and conforming to an FAL ought to be part of a larger risk management process and program. Conforming to FAL3 does not make an organization’s security infallible, but instead provides protection against particular attacks while incurring certain costs to both the applications and the subscribers. Rather than attempting to make your federation infrastructure conform to the highest standards available, you need to analyze the risks that are inherent in your organization and choose how strongly to protect against them given their severity and likelihood of occurrence.</p>

<p>The additional information management and implementation complexity of higher FALs cannot be ignored, and the costs to all involved have to be weighed against perceived benefits. Unless there is a compelling reason to use the features of higher FALs, FAL1 is the default for most use cases. FAL1 is the industry standard for authentication at this point in time. The risks of implementing a system at FAL1, when compared to higher FALs, may be negligible depending on relevant use cases and attack vectors. When PII needs to be passed, it ought to be passed in a secondary channel where possible instead of in the assertion itself, regardless of the FAL.</p>

<p>Because it is the front door to many critical systems, authentication is a key piece of risk management strategy. Strong federation can protect against many potential subscriber impersonation and man-in-the-middle attacks. Instead of each RP needing to manage subscriber accounts and authenticators separately, creating many vulnerable surfaces, federation concentrates the key security practices in a dedicated component, the IdP. Upgrades to authenticators, software, and practices at the IdP automatically benefit the downstream RPs and the overall network.</p>

<h3 id="23-personally-identifiable-information-pii">2.3. Personally Identifiable Information (PII)</h3>

<p>Personally Identifiable Information (PII) needs to be limited to only what’s needed to perform a transaction. For many login transactions, the RP will need to know only an identifier for the current subscriber. After an initial login, this identifier is used by the RP to tie the subscriber to a record in the RP application, and this record often contains attributes collected from various sources including the IdP and direct interaction with the subscriber.</p>

<p>All assertions contain a subject identifier, which uniquely identifies the subscriber represented by the assertion to the RP. Since the subject identifier is required with every assertion, the subject identifier shouldn’t have any PII internally. For example, IdPs wouldn’t use usernames, employee numbers, simple sequences, or other easily predictable and correlatable information for the subject identifier. Instead, to prevent PII leakage, IdPs can use approved cryptography to assign random subject identifiers to all users. Alternatively, IdPs could derive subject identifiers from PII using approved cryptography. For example, the IdP could run an internally unique identifier (like an employee number) through an approved hashing function. The output of the hashing function would be the subject identifier, and the PII used to generate it has been protected since it cannot be re-derived from the output of the hashing function.</p>

<p>Assertions at all levels can include additional attributes about the subscriber [section 6], potentially including PII. The RP might require some of this information to perform its function, such as an email address to contact a subscriber. However, the RP will not know if it needs information for a given subscriber before that subscriber has been logged in, since the required information could be available locally to the RP without requesting it from the IdP. This presents a dilemma for systems trying to practice data minimization.</p>

<p>Some protocols, such as SAML, require all available attributes be present in the assertion itself. In such cases, the RP needs to be very judicious about which attributes it requests. In other protocols, such as OpenID Connect, attributes can be sent through both the assertion and a secondary channel, the UserInfo endpoint. In OpenID Connect the ID Token serves as the assertion, and by default it contains a non-PII subject identifier for the subscriber. Additional information about the subscriber can be obtained through the UserInfo Endpoint by using an OAuth access token. Since this information is communicated in the back channel from the IdP to the RP over a an authenticated protected channel, it need not be separately encrypted as it is not handled or presented by an intermediary party (though of course it can be encrypted as well).</p>

<h3 id="24-selecting-a-presentation-mechanism">2.4. Selecting a Presentation Mechanism</h3>

<p>Assertions can be sent either over the back channel between the IdP and RP [section 7.1] or over the front channel using the subscriber and their browser as an intermediary [section 7.2]. While both methods are allowed at all FALs, back channel presentation has a number of advantages and is preferred where possible.</p>

<p>Since the assertion is transmitted directly from the IdP to the RP over an authenticated protected channel, the RP has a high level of assurance that the assertion is from the IdP in question. The RP can also be sure that the assertion is generated in response to a specific authentication request since the RP needs to present an assertion reference to retrieve it.</p>

<p>Front channel presentation systems are simpler for RPs to implement, as they don’t have to handle assertion references or trading them for assertions. As a consequence, front channel presentation systems can be more susceptible to assertion injection, whereby an attacker can present a valid assertion to an unsuspecting RP in order to force a login at that RP, potentially taking over a session. A back channel presentation system is subject only to injection of an assertion reference, which can be more strongly tied to an authentication request.</p>

<p>To enforce least-privilege and least-knowledge security principles, it is preferable to have each RP request its own assertion instead of re-using one assertion for multiple RPs. With front-channel presentation, it is tempting for a system to create a single assertion to be presented to multiple RPs by the browser. The browser then needs to determine which sites to present the assertion to, and which to request a new assertion for. With a back channel presentation mechanism, only the assertion reference is passed to the RP from the browser. Since the assertion reference is one-time use and limited to a single RP , it cannot be used accidentally multiple times at multiple RPs.</p>

<p>Additionally, assertions passed in the front channel are visible to an intermediary party, the browser. The assertion’s payload, which intended for consumption by the RP, can include PII attributes, internal security information, or other sensitive data. To avoid untended data leakage, the IdP can employ several techniques:</p>

<ol>
  <li>Encrypt the payload to the RP’s key, as is required at FAL2 and FAL3.</li>
  <li>Limit the information contained in the assertion payload to non-sensitive information, and use a secondary mechanism to convey sensitive details such as in section 2.3.</li>
  <li>Use a back-channel presentation mechanism to prevent the assertion itself from being seen by the intermediary.</li>
</ol>

<h3 id="3-guidance-for-relying-parties">3. Guidance for Relying Parties</h3>

<p>While it is the responsibility of the IdP to provide strong and trustworthy federation assertions, relying parties need to validate the elements of an assertion during a federated transaction [section 6.2].</p>

<h4 id="31-purpose">3.1. Purpose</h4>

<p>Relying parties can be a valuable target for attackers to impersonate valid subscribers or gain valuable information about them. If relying parties do not check the validity of the information they receive, attackers can gain access to the various services that subscribers are logging in to.</p>

<p>If all of these checks are performed properly, the compromise of a single relying party does not threaten the rest of the network. This is in contrast to systems with individual authenticators at each site, where the theft of a subscriber’s password from one site often leads to the compromise of other sites in the network due to password reuse.</p>

<h4 id="32-general-guidance">3.2. General Guidance</h4>

<p>Relying parties need to do two major checks against incoming assertions:</p>

<ul>
  <li>Check that the assertion itself is internally consistent</li>
  <li>Check that the assertion is verifiably from a trusted source</li>
</ul>

<p>Relying parties need to validate IdP signatures, assertion expirations, and audience parameters within an assertion to validate that the assertion itself is internally consistent. Additionally, RPs need to test that these validation checks are working at all times because there will be no outward indication that something is wrong with the system until an attack occurs. In other words, RPs need to ensure that they are rejecting invalid assertions just as much as they are accepting valid assertions.</p>

<p>Relying parties need to also verify the origin of the information that they receive, as an attacker might try to inject a valid assertion from another subscriber in order to take over an account. RPs can do this by making sure that the assertion is signed by a trusted IdP’s key and that the assertion isn’t being replayed.</p>

<h5 id="321-validating-idp-signatures">3.2.1. Validating IdP Signatures</h5>

<p>At all FALs, an identity assertion is signed by an IdP so that it cannot be forged by an attacker [section 6.2.2]. The IdP is the only entity with access to its private key [section 4.1], so a valid signature indicates that the assertion is from the IdP itself and not an attacker. If an RP does not check the validity of the IdP signature, attackers will be able to forge identity assertions and gain access to protected systems without authorization. Additionally, if the relying party does not check the signature, an attacker could modify an otherwise valid assertion in transit, associating attributes and access rights to the current subscriber that were not asserted by the IdP.</p>

<p>Some protocols cover the entire assertion with a signature, while others cover only portions of it. The relying party has to take care to not accept unsigned portions of the assertion as validated even when presented alongside a signed assertion.</p>

<p>The RP needs to make sure it is using the correct key for the claimed IdP, especially if the RP accepts assertions from multiple IdPs. In OpenID Connect, for example, the IdP is identified by the “iss” field of the ID Token’s payload, and the signing key is identified by the “kid” field in the ID Token’s header. The RP will accept the token if and only if the signature validates using the identified key from the identified issuer, and then only if the issuer is trusted to provide identities to this RP.</p>

<p>Testing whether RPs will reject unsigned assertions or assertions with invalid signatures is critical, though not an obvious test to do. Properly authorized transactions will still work even if an RP isn’t checking assertion signatures, since the RP will accept the (valid) assertion whether or not it has a valid signature. Therefore, in such cases there is no outward indication of a problem in the system and there will be no error messages or login failures to indicate that something is wrong. Only a failure from a negative test – that is to say, the explicit rejection of an unsigned assertion or an assertion with an invalid signature – will indicate that a relying party is properly checking keys and signatures.</p>

<h5 id="322-checking-assertion-expirations">3.2.2. Checking Assertion Expirations</h5>

<p>Federated identity assertions are intended to be short-lived, since they are used to establish a session at the RP and not to manage a full session at the RP [section 5.2]. While details vary per protocol family, an assertion lasting a small number of minutes will in most cases give the system ample time to process the assertion and create a session for the subscriber. Since federation assertions are passed between different systems on the network, it is reasonable to allow a small amount of padding to the time checks to account for clock skew. This skew ought to be very short, such as a few seconds, so as to not inadvertently open the attacker’s window for using expired assertions. A time synchronization protocol such as NTP can be used on all systems on the network if possible to ensure the system clocks are as accurate as possible.</p>

<p>An identity assertion which expires quickly makes it difficult for attackers to misuse the assertion and also ensures that any identity or authorization information included in the assertion is not out-of-date. RPs need to be tested to ensure they do not accept expired assertions, which can be done by presenting the RP with an expired but otherwise valid assertion and seeing if the RP accepts or rejects it.</p>

<p>Some assertions also contain a timestamp indicating when the assertion was issued, and an RP shouldn’t accept any assertion that claims to have been issued in the future. Some assertions will also have a timestamp indicating when the assertion is not to be used before, which an RP can process to ensure it is not accepting an assertion too early. The use of the “not-before” processing mechanism is relatively rare in modern federation protocols, as the assertions are created in response to specific login requests.</p>

<h5 id="323-checking-audience-parameters">3.2.3. Checking Audience Parameters</h5>

<p>When an IdP creates an assertion, it includes an audience field indicating which RP requested the assertion [section 6.2.4]. By checking the audience field, an RP can detect when an attacker is presenting an assertion intended for a different RP.</p>

<p>If an RP does not check for a matching audience parameter, it is possible for an attacker to get a valid assertion from any RP registered with the IdP and replay it at the target RP to gain unauthorized access.</p>

<p>An RP that isn’t checking audience parameters will still accept a valid authorization with no outward indication of a problem. Therefore, it is important to test the RP with an assertion containing an errant or missing audience field.</p>

<h5 id="324-checking-assertion-uniqueness">3.2.4. Checking Assertion Uniqueness</h5>

<p>An attacker that gains possession of a bearer assertion could try to replay that assertion at an RP in order to take over a subscriber’s session. To prevent this, an IdP is required to make each assertion unique [section 6.2.1]. The RP consequently needs to check the assertion for uniqueness within the assertion’s expiry window by checking any unique identifiers within the assertion and accepting each unique assertion identifier once and only once to establish a session with a single subscriber. If an assertion is seen multiple times by an RP, especially from multiple connections, the RP can consider this assertion stolen.</p>

<p>The RP ought to remember the identifiers of assertions as long as those identifiers are valid. Since assertions have a relatively short lifespan, this can be accomplished without large storage requirements by remembering only otherwise-valid assertion IDs within their validity window. If an assertion is replayed after it has expired, it will be rejected based on its expiration.</p>

<h5 id="325-retrieving-idp-keys">3.2.5. Retrieving IdP Keys</h5>

<p>The RP can trust the assertion’s signature only as much as it can trust that the keys used to verify the signature are associated with the IdP [section 6.2.2]. The keys need to be retrieved in a secure fashion, such as over an authenticated protected channel or pre-placed by a systems administrator. Only the keys identified in the assertion can be used to evaluate the signature of an assertion.</p>

<h4 id="33-guidance-by-product-family">3.3. Guidance by Product Family</h4>

<p>This document covers two main product families that enable federated identity transactions - SAML and OpenID Connect, the latter of which is built on top of OAuth. Other protocols and approaches are possible to use while fulfilling the requirements of the guidelines.</p>

<h5 id="331-saml">3.3.1. SAML</h5>

<p>All parties need to be careful about passing and validating metadata. Incorrectly communicated or configured metadata could leak information about a subscriber that was not approved for distribution. Metadata that is not validated could have been tampered with by an attacker to gain access to valuable personal information.</p>

<p>Always check certificates before accepting identity assertions. Attackers can forge certificates and phish subscribers in an attempt to impersonate them.</p>

<h5 id="332-openid-connect">3.3.2. OpenID Connect</h5>

<p>Different OAuth grant types or “flows” are appropriate for different kinds of applications at different FALs.</p>

<p>The authorization code flow is a back-channel presentation mechanism and ought to be used whenever possible, particularly for web server, native, or mobile applications. It is the most common and most secure way to implement OAuth, the underlying protocol of OpenID Connect. It can accommodate all three FALs depending on the exact configuration of the application. The authorization code flow makes use of back channel assertion presentation, which reduces the attack surface of the RP significantly by sending the assertion directly from the IdP to the RP without an intermediary party touching it. The RP ought to authenticate itself when presenting the authorization code to the IdP. If the RP is a native or mobile application, it can use the <a href="https://tools.ietf.org/html/rfc7636">PKCE extension</a> or <a href="https://tools.ietf.org/html/rfc7591">dynamic client registration</a> to ensure that different copies of the client software can’t impersonate each other at the IdP.</p>

<p>The implicit grant type is a front-channel presentation mechanism and is appropriate for applications which are implemented entirely in front-end code and have to capability to store secrets outside of the subscriber’s web browser. The lack of ability to store secrets means that these sorts of applications can only function at FAL1 because they have no method of private key management which would enable encryption of identity assertions.</p>

<p>The hybrid grant types are allowable only if all appropriate checks are made by the RP as defined in the standard. The <code class="highlighter-rouge">client credentials</code> and <code class="highlighter-rouge">resource owner credentials</code> grant types are not allowed at any FAL.</p>

<h3 id="4-guidance-for-identity-providers">4. Guidance for Identity Providers</h3>

<p>The nature of federation protocols allows the IdP to specialize in security in a way that benefits all RPs that connect to it. With traditional application security methods, such as having a password on each RP, every RP is fully responsible for its security. However, due to common practices like password reuse, compromise of a single RP can lead to the compromise of many other RPs for a given account. In a federation network, the identity provider (IdP) is the only party that can assert the presence and validity of subscribers and their attributes. The compromise of a single RP does not cascade through the network. Instead, the security of all subscribers rests on the security of their IdP. Consequently, a compromise of the IdP will affect all downstream parties. As such, it is vitally important that the IdP be held to the highest of security standards in implementation and deployment.</p>

<h4 id="41-purpose">4.1. Purpose</h4>

<p>As the lynchpin of security in a federation network, IdPs have the difficult task of keeping track of both subscribers and RPs, and connecting them in a secure fashion with a federation protocol. However, unlike RPs that are trying to provide a service or application, the IdP’s primary purpose is to act as a security component for the rest of the federation. As a specialty service, it makes sense to invest heavily in good security practices.</p>

<h4 id="42-general-guidance">4.2. General Guidance</h4>

<p>IdPs manage the primary authenticators and authentication processes for subscribers in a federation. Guidance for managing such authentication can be found in [SP 800-63B], all of which needs to be applied at the IdP. In particular, IdPs ought to implement phishing-resistant technologies in subscriber-facing pages and may want to consider the use of heuristic or risk-based security for all connections, including APIs. Additionally, the attributes and identities asserted by the IdP are subject to whatever verification practices the IdP uses. Guidelines for such identity proofing and verification are found in [[SP 800-63A]].</p>

<p>Much of the technical friction in setting up a federation stems from IdPs which are built and configured in such a way that onboarding new RPs requires a significant amount of manual human intervention [section 5.1.1]. Any time there is unwarranted friction in a security process, the consumers of that process (in this case RP implementors) will often find creative and usually-insecure workarounds to that process. Much of this friction is removed when IdPs support automated discovery mechanisms and simple automated registration [section 5.2.2]. In order to ease RP onboarding, IdPs ought to make their configurations discoverable in a machine-readable format over a secure protected channel, as appropriate to the protocol in use.</p>

<p>IdPs need to use approved cryptographic systems to generate all key material [section 4.1]. IdPs also need to securely store all private key material in such a way that attackers, RPs, end users, and other parties do not have access to the private key. Public keys need to be made available to RPs over authenticated protected channels or via trusted out of band processes, such as hand configuration by a systems administrator. An IdP can use a single key pair across different RPs on the network, and the keys can be rotated on a regular basis.</p>

<p>The IdP’s private keys, which are used to sign assertions, need to be protected from subscribers, RPs, and other unintended parties. If the IdP’s private keys are compromised, an attacker could generate arbitrary assertions and impersonate any subscriber on the network at any RP. If an RP’s keys are compromised, an attacker could impersonate a request from that RP but not attack any other RPs or the IdP itself.</p>

<p>IdPs have to securely store any symmetric secrets used by RPs in a fashion that reduces the likelihood of their capture, such as by storing a hash of the secret instead of the secret itself. All symmetric secrets need to be generated using approved cryptography, and a different secret needs to be generated for every RP that the IdP associates with. Similarly, if an RP talks to multiple IdPs, it has to have a separate secret for each IdP.</p>

<p>If an IdP provides public and private keypairs to subscribers or RPs, the IdP need to store only the public portion of the key.</p>

<h4 id="43-guidance-by-product-family">4.3. Guidance by Product Family</h4>

<p>This document covers two main product families that enable federated identity transactions - SAML and OpenID Connect, the latter of which is built on top of OAuth. Other protocols and approaches are possible to use while fulfilling the requirements of the guidelines.</p>

<h5 id="431-saml">4.3.1. SAML</h5>

<p>Both IdPs and RPs ought to publish metadata in a well-known location. While there is no widely accepted standard for SAML metadata exchange, it is advisable to use a well-documented metadata endpoint to serve the IdPs metadata in the form of a single XML file to any RP who wishes to consume it.</p>

<p>The IdP needs to always check signatures on metadata, and only accept metadata that has been signed by the presenting RP.</p>

<p>Identity federations like <a href="https://www.incommon.org/">InCommon</a> share the metadata of hundreds of IdPs and RPs in a structured manner [section 5.1.3]. Adding an IdP’s metadata to such federations will help RPs to find it easily.</p>

<p>Apply best practices to protect subscriber information. All SAML assertions containing personally identifiable information ought to be encrypted to the relying party to protect the PII from being leaked to the browser. Assertions containing only authentication information and no personally identifiable information can relax this encryption requirement.</p>

<h5 id="432-openid-connect">4.3.2. OpenID Connect</h5>

<p>IdPs can use OpenID Connect’s discovery mechanism, published in JSON format at an HTTPS location ending in <code class="highlighter-rouge">/.well-known/openid-configuration</code> as specified in the OpenID Connect discovery specification. The discovery document contains all of the information that an RP would need to interact with the server. This document is usually made available in a location based on the IdP’s unique issuer URL.</p>

<p>If personally identifiable information is bundled with authentication information in a token, it ought to be protected through encryption of the ID Token or use of a back-channel presentation mechanism. If personally identifiable information is made available at the UserInfo Endpoint, such assertions need not be encrypted but have to instead be passed over an authenticated protected channel (HTTPS and TLS).</p>

<p>It is recommended that OpenID Connect IdPs support a dynamic client registration to make it easy for RPs to register without manual intervention. Note that dynamic registration does not release data to the RP, it merely allows the RP to ask for login to be authorized at runtime [section  4.2].</p>

<p>There is a test suite for OpenID Connect providers to verify whether their instance of OpenID Connect is compliant with the standard, available from <a href="http://openid.net/certification/testing/">http://openid.net/certification/testing/</a>.</p>

<p>The OpenID Connect community has reviewed libraries in several different languages to search for bugs and non-compliant processes, available at <a href="http://openid.net/developers/libraries/">http://openid.net/developers/libraries/</a>. Whenever possible, leverage these libraries in development.</p>

<p>OpenID Connect relies heavily on the <a href="https://datatracker.ietf.org/wg/jose/about/">JOSE standard</a>, particularly JWT and JWK. All tokens an keys in an implementation have to conform to those standards. It is recommended that IdPs use an established JOSE and JWT library to ensure all appropriate checks have been made during implementation.</p>

<p>Additional security standards like <a href="https://datatracker.ietf.org/wg/tokbind/documents/">token binding</a> and <a href="https://tools.ietf.org/html/rfc7636">proof key for code exchange</a>. While those standards are not factors in determining the FAL of an OpenID Connect IdP, they considered to be best practice in the industry.</p>

<h3 id="5-example-scenarios">5. Example Scenarios</h3>

<h4 id="51-shibboleth-and-saml">5.1. Shibboleth and SAML</h4>

<p>SAML Federations like InCommon can operate at FAL1 or FAL2. Most InCommon IdPs are running on a Shibboleth identity provider. They pass assertions through a response to an authentication event. Most often, those assertions are not encrypted to the RP and therefore conform to FAL1. For a Shibboleth IdP, either encrypt all assertions to the RP or refrain from sending personally identifiable information such as <code class="highlighter-rouge">eduPersonPrincipalName</code> (or <code class="highlighter-rouge">eppn</code>) over the wire as an unencrypted SAML assertion.</p>

<p>SAML could reach FAL3 by providing an attribute within the SAML assertion that references a cryptographic key to be presented by the subscriber at the RP.</p>

<h4 id="52-openid-connect">5.2 OpenID Connect</h4>

<p>Typically, OpenID Connect Providers interact with OpenID Connect relying parties by providing a signed authentication assertion (the ID Token) which is separate from the transfer of personally identifiable information (from the UserInfo Endpoint). As such, these providers can safely operate at FAL1 because they are not bundling identity assertions with authentication information. This characterization is true for both the authorization code and implicit client types.</p>

<p>If the ID Token contains personally identifiable information, it needs to be encrypted to the RP at FAL2. This is accomplished by using the JSON Web Encryption (JWE) specification and a key registered to the client.</p>

<p>OpenID Connect could reach FAL3 by providing a claim within the ID Token that references a cryptographic key to be presented by the subscriber at the RP.</p>

<h4 id="53-personal-identity-verification-piv-card">5.3 Personal Identity Verification (PIV) Card</h4>

<p>PIV cards are considered an authentication technology by the SP 800-63 guidelines, not a federation technology. However, PIV cards can be used to authenticate to an IdP and start a federation transaction. This approach allows the complex processing and validation of the PIV certificate chain to be handled by a specialized security component, the IdP, and identity information be sent to the downstream RPs by the federation protocol. The attributes contained in the PIV certificates can be transmitted by the IdP to the RP, assuming all consent and privacy considerations around attribute release have been followed as usual.</p>

<p>FALs are independent of AALs, and any authentication device may be used to start a federation transaction at any FAL. Therefore, the use of a PIV does not guarantee a high FAL, but it can help.</p>

<p>There are many benefits to using federated identity management as opposed to requiring independent registration of PIV cards for each subscriber. Federated identity management protocols such as OpenID Connect allow subscribers to authenticate at a relying party regardless of which authenticator they use at their IdP. This allows relying parties to securely accept registered subscribers whose IdPs do not use PIV cards.</p>

<h4 id="54-privacy-enhancing-federated-identity">5.4 Privacy-enhancing Federated Identity</h4>

<p>In many cases, relying parties do not need to know the full identity of a subscriber. Relying parties need to request only as much information as they need to complete the transaction requested by the subscriber, and IdPs need to limit what information relying parties have access to within a transaction [section 5.2]. Furthermore, with protocols like OpenID Connect, the attributes of the subscriber can be sent separately from the assertion itself, limiting leakage of this information.</p>

<p>Pairwise identifiers ought to be used in place of persistent or correlatable identifiers whenever possible [section 6.3]. This limits relying parties in attempts of tracking or identifying individual subscribers across different systems.</p>

<p>When possible, claim references ought to be used to communicate identity information rather than raw data [section 7.3]. For example, if a relying party needs to know whether a subscriber is over eighteen years old, the IdP can respond that the subscriber is over eighteen without sharing the subscriber’s age or birthdate.</p>

<h4 id="55-parallel-authentication">5.5 Parallel Authentication</h4>

<p>In some cases a relying party may wish to confirm certain aspects of a subscriber’s identity above and beyond what the IdP provides. For example, a relying party could log in a subscriber using an IdP, receive a picture of the subscriber from the IdP, and require that an in-person agent verify that the picture matches the identity of the person authenticating. This use case is known as “parallel authentication” because two authentication events are happening next to each other: the assertion, and the verification of the biometric (photo) by a trusted agent. The focus of FAL is primary on the assertions being passed from the IdP to the RP, so most authentication events occurring at the RP would not affect the FAL of the transaction.</p>

<p>At FAL3, holder-of-key transactions occur by verifying both the assertion from the IdP as well as the subscriber’s presentation of proof of their personal key attested to in the assertion.</p>

<h3 id="6-brokered-identity-management">6. Brokered Identity Management</h3>

<p>Some federated identity architectures are based on brokered identity management [section 5.1.4], where a single broker intermediates transactions between registered IdPs and RPs. In this architecture, each entity in the system only has to register with one broker in order to interoperate with everyone else in the system. It also means that an IdP can authenticate a subscriber without knowledge of which RP requested the authentication event.</p>

<p>Recent advances in automated registration processes have made IdP/RP integrations much less onerous than they used to be. It is possible for an IdP and RP to register with each other in a very short amount of time without any manual processes. This has lessened the value of brokered identity architectures, since interoperability can be simple and fast even without a central broker.</p>

<p>While brokered identity management systems may appear to protect privacy by blinding an IdP from an RP, keep in mind that the broker itself is aware of all the parties involved in the transaction, and in some cases can see personally identifiable information about subscribers. Brokered identity management systems do not prevent subscriber tracking all together, they merely shift the ability to track subscribers from the IdPs and RPs to the broker.</p>

<p>Additionally, because brokers have access to active valid identity assertions, they are capable of impersonating subscribers. This increases the risk inherent in the entire architecture, since the broker represents a single point of failure which, if it is compromised, can in turn compromise every participant in the system.</p>

<p>NIST has been promoting privacy-enhancing technology in the brokered identity management space through the <a href="https://nccoe.nist.gov/projects/building-blocks/privacy-enhanced-identity-brokers">Privacy-Enhanced Identity Federation project</a>. This NIST building block outlines a set of goals which would constitute a new kind of brokered architecture. This architecture leverages a broker which cannot impersonate or track subscribers. This architecture is still theoretical, and may allow for a privacy-preserving and secure version of brokered identity management in the future.</p>

<h3 id="7-educational-resources">7. Educational Resources</h3>

<p>All specifications for identity federation standards are freely available online:</p>

<p><a href="https://tools.ietf.org/html/rfc6749]">OAuth 2 (RFC 6749)</a><br />
<a href="http://openid.net/connect/">OpenID Connect</a><br />
<a href="http://saml.xml.org/saml-specifications">Security Assertion Markup Language</a></p>

<p>These specifications outline multiple, sometimes mutually exclusive ways to implement federated identity, so be sure to read the specifications in their entirety before creating an implementation.</p>

<p>Federation standards communities actively track known vulnerabilities in existing standards.</p>

<p>The IETF lists OAuth Security Concerns in in <a href="https://tools.ietf.org/html/rfc6819">RFC 6819</a> and hosts a <a href="https://tools.ietf.org/wg/oauth/">working group</a> to track OAuth standards and vulnerabilities.</p>

<p>The OpenID Foundation lists OpenID Connect security concerns <a href="http://openid.net/specs/openid-connect-core-1_0.html#Security">within the specification itself</a> and hosts a <a href="http://openid.net/wg/connect/">working group</a> which actively tracks vulnerabilities.</p>

<p>OASIS has published <a href="http://docs.oasis-open.org/security/saml/v2.0/saml-sec-consider-2.0-os.pdf">SAML Privacy and Security Considerations</a> and hosts a <a href="https://lists.oasis-open.org/archives/security-services/">mailing list</a> to track SAML vulnerabilities.</p>

<h3 id="8-communicating-with-stakeholders">8. Communicating with Stakeholders</h3>

<p>Stakeholders need to be aware that selecting an FAL is part of a larger risk- and resource-management process. While it is tempting for stakeholders to request the highest level of security, that is not always in the best interest of the organization. Federated identity projects at higher FALs can be long and complicated, and such complications can take resources away from other work that a security team could be doing that would be of greater benefit to the organization.</p>

<p>Many organizations today operate at FAL1, which is sufficient for most use cases. FAL1 is the industry standard, and there are many libraries and off-the-shelf products that can help an organization implement an FAL1 conformant federated identity system.</p>

<p>Conformance to FAL2 or FAL3 is appropriate for some business cases where there is a risk of fraudulent activity which would be prevented by token encryption, or when the transactions protected by the login is of particularly high value to warrant the additional complexity.</p>

<h3 id="9-conclusion">9. Conclusion</h3>

<p>There are many ways to secure federated identity transactions, and many products do a very adequate job of it today, but there are ways to improve security posture with regard to federation if doing so makes sense in an overall risk management framework.</p>

  </div>
</div>

<footer role="contentInfo" class="site-footer">
  <div class="section-container">
    <div class="section-content">
    </div>
  </div>
</footer>

<hr>
<section class="footer">
<br><a target="_blank" href="http://www.nist.gov/public_affairs/privacy.cfm#privpolicy">Privacy Policy</a> | <a target="_blank" href="http://www.nist.gov/public_affairs/privacy.cfm#secnot">Security Notice</a> | <a href="http://www.nist.gov/public_affairs/privacy.cfm#accesstate">Accessibility Statement</a> | <a href="https://github.com/usnistgov/800-63-3/issues/">Send feedback</a>
  <a href="/RC-800-63-3/comment_help.html" class="icon icon-fa">
    <i class="fa fa-question-circle" title="Get help with leaving a comment" aria-hidden="true"></i>
    <span class="sr-only">Get help with leaving a comment</span>
  </a>
</section>

</body>
</html>